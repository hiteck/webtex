# Copyright 2014 Peter Williams and collaborators.
# Licensed under the MIT license. See LICENSE.md for details.

builddir = build
python = python
texdist = tl2013
pdfjsversion = 1.0.712
yuiversion = 2.4.8

default: all


# Source files for the main JavaScript apps.

genlists = \
  data/commands.txt \
  data/namedparams.txt

# Non-TeX-specific low-level utilities
sharedjs = \
  src/preamble.js \
  src/format.js \
  src/inflate.js \
  src/jsonparse.js \
  src/zipreader.js

# Basic classes, constants
sharedjs += \
  src/constants.js \
  src/str-utils.js \
  src/numerics.js \
  src/base-classes.js \
  src/values.js \
  src/valrefs.js \
  src/token.js

# I/O infrastructure
sharedjs += \
  src/linebuffer.js \
  src/ordsource.js \
  src/inputstack.js \
  src/iostack.js \
  src/bundle.js \
  src/document-archive.js

# High-level features
sharedjs += \
  src/modes.js \
  src/registers.js \
  src/parameters.js \
  src/conditionals.js \
  src/fonts.js \
  src/listables.js \
  src/boxes.js \
  src/paragraphs.js \
  src/inserts.js \
  src/math.js \
  src/align.js \
  src/page-builder.js \
  src/command-classes.js \
  src/command-impls.js \
  $(builddir)/intermediates/engine-helpers.js \
  src/engine.js \
  src/ship-target.js \
  src/html-translate-target.js

$(builddir)/intermediates/%-helpers.js: \
dev-scripts/preprocess.py src/%-helpers-tmpl.js $(genlists) \
| $(builddir)/intermediates
	$(python) $< src/$*-helpers-tmpl.js $@


# The first version of Webtex that we build is the Node.js version. We require
# this to create the ".dump.json" files that will go into the bundle.

nodejs = \
  src/node-io.js \
  src/node-api.js

$(builddir)/node-webtex.js: \
dev-scripts/preprocess.py src/node-wrapper.js $(preamble) $(sharedjs) $(nodejs) \
| $(builddir)/intermediates
	$(python) $^ $@

primaries += $(builddir)/node-webtex.js


# Here we build the bundle and those .dump.json files that it requires. To
# force a rebuild of the bundle, use "touch data/packages.txt" so that
# make-bundle.py can move away the old bundle file for tidiness.

bundleextras = \
  $(builddir)/latex.dump.json

$(builddir)/latex.dump.json: \
dev-scripts/dump-format.js $(builddir)/node-webtex.js texpatches/$(texdist)/latex.ltx.post \
| $(builddir)
	node $< $(builddir)/node-webtex.js texpatches/$(texdist)/ latex.ltx $@

$(builddir)/plain.dump.json: \
dev-scripts/dump-format.js $(builddir)/node-webtex.js \
| $(builddir)
	node $< $(builddir)/node-webtex.js texpatches/$(texdist)/ plain.tex $@

$(builddir)/dev/dev-bundle.zip $(builddir)/glyph-encoding.json: \
dev-scripts/make-bundle.py data/packages.txt data/mapfiles.txt $(bundleextras) \
| $(builddir)/dev $(builddir)/old-bundles
	$(python) $< data/packages.txt data/mapfiles.txt texcache $(builddir) texpatches $(bundleextras)


# Next up is the browser version of Webtex. This is split into two parts: the
# "backend", which contains the TeX engine and does all the processing, and
# the "frontend", which just renders the backend's output. The backend is run
# as a Web Worker thread. It and the Node.js version are 99% the same, just
# with different I/O backends (local files vs. web requests) and exposing
# their APIs in different ways.

backendjs = \
  src/browser-io.js \
  src/backend-api.js

$(builddir)/dev/webtex-backend.js: \
dev-scripts/preprocess.py src/backend-wrapper.js $(sharedjs) $(backendjs) \
| $(builddir)/dev
	$(python) $^ $@

primaries += $(builddir)/dev/webtex-backend.js
devfiles += $(builddir)/dev/webtex-backend.js
distfiles += $(builddir)/dev/webtex-backend.js

# The frontend, which drives the backend and renders its output into the DOM.
# This can only be built after the bundle, because the frontend code embeds
# the list of glyph identifiers, which is generated as font files in the
# bundle are processed. The frontend does *not* include all of the code for
# the TeX engine; it only has code to display the intermediate ("chrome") data
# format generated by the backend.

frontendjs = \
  src/preamble.js \
  src/format.js \
  src/master-object.js \
  $(builddir)/intermediates/frontend-glyph-helper.js \
  src/type1-font.js \
  src/dom-renderer.js

$(builddir)/dev/webtex-frontend.js: \
dev-scripts/preprocess.py src/frontend-wrapper.js $(frontendjs) \
| $(builddir)/dev
	$(python) $^ $@

primaries += $(builddir)/dev/webtex-frontend.js
devfiles += $(builddir)/dev/webtex-frontend.js
distfiles += $(builddir)/dev/webtex-frontend.js

$(builddir)/intermediates/frontend-glyph-helper.js: \
dev-scripts/preprocess.py src/frontend-glyph-helper-tmpl.js $(builddir)/glyph-encoding.json \
| $(builddir)/intermediates
	$(python) $^ $@


# We use an internal copy of PDF.js to render PDF figures. These rules
# download and unpack it and link its files into the local development
# environment.

pdfjs_unzip_stamp = $(builddir)/pdfjs/build/pdf.js

$(builddir)/pdfjs-$(pdfjsversion)-dist.zip: \
| $(builddir)
	curl -L https://github.com/mozilla/pdf.js/releases/download/v$(pdfjsversion)/pdfjs-$(pdfjsversion)-dist.zip >$@

$(pdfjs_unzip_stamp): \
$(builddir)/pdfjs-$(pdfjsversion)-dist.zip \
| $(builddir)
	rm -rf $(builddir)/pdfjs
	mkdir -p $(builddir)/pdfjs
	cd $(builddir)/pdfjs && unzip -q -DD ../pdfjs-$(pdfjsversion)-dist.zip

$(builddir)/dev/compatibility.js: \
$(pdfjs_unzip_stamp) \
| $(builddir)/dev
	cd $(builddir)/dev && ln -s ../pdfjs/web/compatibility.js

$(builddir)/dev/pdf.js: \
$(pdfjs_unzip_stamp) \
| $(builddir)/dev
	cd $(builddir)/dev && ln -s ../pdfjs/build/pdf.js

$(builddir)/dev/pdf.worker.js: \
$(pdfjs_unzip_stamp) \
| $(builddir)/dev
	cd $(builddir)/dev && ln -s ../pdfjs/build/pdf.worker.js

primaries += $(pdfjs_unzip_stamp)
devfiles += \
  $(builddir)/dev/compatibility.js \
  $(builddir)/dev/pdf.js \
  $(builddir)/dev/pdf.worker.js
distfiles += \
  $(builddir)/dev/compatibility.js \
  $(builddir)/dev/pdf.js \
  $(builddir)/dev/pdf.worker.js


# Here we link the chrome data files into the local development environment.
# Too bad that we're encoding an absolute path to the data/fronted/ directory,
# but I'd rather do that than rely on the location of $(builddir). (Call me
# Mr. Overkill.)

$(builddir)/dev/dev-frontend-data: \
| $(builddir)/dev
	d=`cd data/frontend && pwd` ; cd $(builddir)/dev && ln -s $$d dev-frontend-data

devfiles += $(builddir)/dev/dev-frontend-data


# These rules produce HTML drivers for the local development environment.

$(builddir)/dev/dev-%.html: \
demo/drivers/%.html.in \
$(builddir)/dev/dev-bundle.zip \
| $(builddir)
	sed -e "s|@BUNDLE@|dev-bundle.zip|g" \
	    -e "s|@CHROME@|dev-frontend-data|g" $< >$@.new \
	 && mv -f $@.new $@

devfiles += $(patsubst demo/drivers/%.in,$(builddir)/dev/dev-%,$(wildcard demo/drivers/*.in))


# These rules produce demo files for the local development environment.

$(builddir)/dev/brockton.zip: \
| $(builddir)/dev
	zip -j $@ demo/brockton/*

$(builddir)/dev/brockton.json: \
webtex \
$(builddir)/node-webtex.js \
| $(builddir)/dev
	./webtex -n3 -T chrome demo/brockton/paper.tex >$@.new && mv -f $@.new $@

devfiles += $(builddir)/dev/brockton.zip $(builddir)/dev/brockton.json
distfiles += $(builddir)/dev/brockton.zip $(builddir)/dev/brockton.json


# Now we work on the "distribution" Zip, which is pretty much like the local
# development environment, but without some of the dev-oriented files and
# referencing big data files in our fakey CDN. You can unzip it and run Webtex
# on your machine through a localhost HTTP server, or by copying to a real Web
# server of your own. First, these rules produce driver HTML drivers
# customized for the distribution.

$(builddir)/dev/%.html: \
demo/drivers/%.html.in \
$(builddir)/dev/dev-bundle.zip \
| $(builddir)/intermediates
	zbase=$$(basename $$(readlink $(builddir)/dev/dev-bundle.zip)) ; \
	sed -e "s|@BUNDLE@|http://webtex.newton.cx/bundles/$zbase|g" \
	    -e "s|@CHROME@|http://webtex.newton.cx/latest|g" $< >$@.new \
	 && mv -f $@.new $@

distfiles += $(patsubst demo/drivers/%.in,$(builddir)/dev/%,$(wildcard demo/drivers/*.in))


# Here make the distribution Zip itself.

distfiles += demo/drivers/README.md demo/drivers/local-server.js

$(builddir)/distrib.zip: \
$(distfiles) \
Makefile \
| $(builddir)
	@dstem=distrib-$(texdist)-`date +%Y%m%d`.zip ; \
	rm -f $(builddir)/$$dstem $@ ; \
	zip -j $(builddir)/$$dstem $(distfiles) ; \
	ln -s $$dstem $@ ; \
	echo Created $(builddir)/$$dstem

distrib: $(builddir)/distrib.zip


# Minifying. Not something I've explored much so far.

minify = java -jar build/yuicompressor-$(yuiversion).jar

$(builddir)/yuicompressor-$(yuiversion).jar: \
| $(builddir)
	curl -L https://github.com/yui/yuicompressor/releases/download/v$(yuiversion)/yuicompressor-$(yuiversion).jar >$@

%.min.js: %.js build/yuicompressor-$(yuiversion).jar
	$(minify) $< >$@.new && mv -f $@.new $@


# Testing. TODO: :-(

test:
	@echo I am a bad person and there are no tests.


# Utility

server: $(devfiles)
	node dev-scripts/testing-server.js $(builddir)/dev &


# Generic helpers

all: $(primaries)

dev: $(devfiles)

$(builddir):
	mkdir -p $@

$(builddir)/intermediates:
	mkdir -p $@

$(builddir)/dev:
	mkdir -p $@

$(builddir)/old-bundles:
	mkdir -p $@

clean:
	-rm -rf $(builddir)

.PHONY: all clean default dev distrib server test
